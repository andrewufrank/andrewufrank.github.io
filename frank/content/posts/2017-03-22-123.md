---
id: 123
date: 2017-03-22T11:14:00+00:00
author: Andrew Frank
layout: post
permalink: /123/
blogger_blog:
  - andrewufrank.blogspot.com
blogger_author:
  - andrew
blogger_permalink:
  - /2017/03/the-haskell-tool-stack-for-multi.html
blogger_internal:
  - /feeds/3533242289707427914/posts/default/8411551473964428228
categories:
  - Uncategorized
---
<h2>The Haskell Tool Stack for Multi-Package Projects</h2><br />I organize my coding in projects, which include several packages, but are managed in a single git repository; a single repository coordinates changes in different packages to be able to reproduce consistent states of the code. In this blog I want to document methods to deal with such arrangements using the new Haskell Stack build methods and postpone a discussion of such Multi-Package Project organization for another time.<br /><br />The Stack project is an effort to overcome one of the major impediments of complex Haskell projects. Haskell packages are versioned and cabal and the linker check <br /><br /><ul><li>the dependencies between packages and their versions, assuring that an acceptable version of a dependent (used) packages is present</li><li>from each package only one version is present in the build.</li></ul><br />It may be difficult to find a set of versions of the required packages, which are consistent; finding such consistent sets is partially automated by cabal install. Two major issues are observed:<br /><ul><li>solutions are not really reproducible and may change by actions outside of the programmers control (e.g. new package version appear)</li><li>the algorithm may not find an acceptable solution; with some tricks and detective work, a solution can be found, sometimes not - the frustration is known as "cabal hell"</li></ul><br />Haskell Stack overcomes these impediments by proposing curated sets of package version which are known to fit together; these are known as snapshots or "lts" and are imported from&nbsp; <a href="https://www.stackage.org/%20repository">Stackage</a> (similar to importing data about versions found on Hackage in cabal). <br /><br />Using the Haskell Tool Stack starts following the <a href="https://docs.haskellstack.org/en/stable/README/">installation guidelins</a> &nbsp; is installing a complete Haskell environment in locations different than what GHC and cabal usually uses (i.e. you get a new copy of ghc in <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">~/.stack</span>)<br /><br />Directories used<br /><ul><li><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">ghc</span> and other global things go into <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">~/.stack</span> </li><li>binaries go into <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">~/.local/bin</span>&nbsp; (the result of <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">getAppUserDataDirectory</span>) </li></ul><br />The <a href="https://docs.haskellstack.org/en/stable/GUIDE/">guidelines</a> &nbsp;&nbsp; to install stack and to run a simple new project are easy to follow and work; in the following, I assume an installed stack. <br /><br />The <a href="https://github.com/lierdakil/test-stack-multiproject.git">example project</a> used here consists of two packages, <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">a</span> and b, a is a library (and a test suite), b is an executable using some of the functions in a.&nbsp; <br /><br />Stack relies on a <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">stack.yaml</span> file, which for this project is <br /><br /><blockquote><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">flags: {}<br />extra-package-dbs: []<br />packages:<br />- a<br />- b<br />extra-deps: []<br />resolver: lts-8.2</span></blockquote><br />This fixes the snapshot to lts-8.2 (newest in march 2017 would be 8.5), which uses ghc 8.0.2 (lts-7.20 is the latest for ghc 8.0.1, for others see on <a href="https://www.stackage.org/%20repository">stackage</a>). As long as the resolver for a project is not changed, the same versions of packages are used and the build is repeatable. <br /><br />The difference to a single package project stack.yaml file is to replace for packages the entry&nbsp; <br /><blockquote><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">packages:</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">- "."&nbsp; </span></blockquote>with the names of the package directories. <br /><br />Extending the multi-project test with a subdirectory with libraries m and n (in the <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">librarySubdir</span> branch) requires additions to stack.yaml<br /><blockquote><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">flags: {}<br />extra-package-dbs: []<br />packages:<br />- a<br />- b<br />- libs/m<br />- libs/n<br />extra-deps: []<br />resolver: lts-8.2</span></blockquote>Stack builds the project and updates the required parts after updates automatically. <br /><br /><br />P.S.<br />Autocompletion for stack requires <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">eval "$(stack --bash-completion-script stack)"&nbsp; </span><br /><br />which can be included in <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">.bashrc</span>